# R List & Python Dictionary {#list-dict-p03}

```{r 'setup', include=FALSE}
source("_common.R")
```

## R List

- R `list` : [CRAN Lists](https://cran.r-project.org/doc/manuals/R-intro.html#Lists)
  - An R `list` is an object consisting of an ordered collection of objects known as its 'components'. 
    - Each component can be of any type of R object and of any length. It can even include `list`, `environment` etc.
  - Components are always numbered. Components may also be named.
  - The vector of `names` is in fact simply an attribute of the list.
  - $[[ \ldots ]]$ vs. $[ \ldots ]$
    - `[[ ]]` is the operator used to select a single element, whereas `[ ]` is a general subscripting operator. 
    - Thus `[[ ]]` provides the first object in the list, and if it is a named list the `name` is not included. 
    - However, `[ ]` provides a sublist of the list consisting of the first entry only. If it is a named list, the `names` are transferred to the sublist.
  - `list` is a `vector` but not an 'atomic vector'

```{r 'R-List-1', decorate=TRUE}
aa = list()                                       #Empty List
print(aa)

aa <- list(x = c(11, 12), y = c("a", "b", "c"))   #Simple List
print(aa)                                         #Print

str(aa)                                           #Structure
```

```{r 'R-List-2'}
aa <- list(x = c(11, 12), y = c("a", "b", "c"))   #Simple List
length(aa)                                        #Count components

lengths(aa)                                       #Count elements of components
```

```{r 'R-List-3'}
aa <- list(x = c(11, 12), y = c("a", "b", "c"))   #Simple List
names(attributes(aa))                             #Attributes

names(aa)                                         #Names of components

sapply(aa, typeof)                                #Type of components
```

```{r 'R-List-4'}
aa <- list(x = c(11, 12), y = c("a", "b", "c"))   #Simple List

bb <- aa[[1]]                                     #[[ ]] First Object: index 1
print(bb)
str(bb)

dd <- aa[1]                                       #[ ] Sublist with First Entry
print(dd)
str(dd)
```

```{r 'R-List-5'}
aa <- list(x = c(11, 12), y = c("a", "b", "c"))   #Simple List

# 'list' is a 'vector' but not an 'atomic vector'
is.list(aa)
is.vector(aa)
is.atomic(aa)
```

## Python Dictionary

- Python `dict` : [Python Dictionary](https://docs.python.org/3/library/stdtypes.html#mapping-types-dict)
  - `dict` : Literal `{}`, Ordered, Mutable, No Duplicates
  - Dictionaries compare equal if and only if they have the same (key, value) pairs (regardless of ordering).
  - Essentially it means 'insertion ordered' which is different from ordered like `OrderedDict`
  - Equality comparisons with `OrderedDict` are order sensitive but this is not the case for `dict`


- [Refer](https://docs.python.org/3.9/whatsnew/3.9.html#dictionary-merge-update-operators)

```{python 'Y-Dict-1', decorate=TRUE}
pp = {}                                           #Empty Dictionary
print(f"{type(pp) = } | {len(pp) = } | {pp = }")

pp = {"x": [11.0, 12.0], "y": ("a", "b", "c")}    #Simple Dictionary
print(f"{len(pp)=}, {pp = }")

```

```{python 'Y-Dict-2'}
pp = {"x": [11.0, 12.0], "y": ("a", "b", "c")}    #Simple Dictionary
len(pp)                                           #Count key: value pairs

{k:len(v) for k, v in pp.items()}                 #Count length of each pair

```

```{python 'Y-Dict-3'}
pp = {"x": [11.0, 12.0], "y": ("a", "b", "c")}    #Simple Dictionary

list(pp.keys())                                   #List of keys

list(pp.values())                                 #List of Values

list(pp.items())                                  #List of items

print("\n".join([k + " : " + str(type(pp[k]).__name__) 
                for k, v in pp.items()]))         #Type of items

```

```{python 'Y-Dict-4'}
pp = {"x": [11.0, 12.0], "y": ("a", "b", "c")}    #Simple Dictionary

qq = list(pp.items())[0]                          #First Object: index 0
print(f"{type(qq) = } | {len(qq) = } | {qq = }")  #Converted to Tuple

qq = pp['x']                                    
print(f"{type(qq) = } | {len(qq) = } | {qq = }")  #Keep original as list

```

```{python 'Y-Dict-5'}
pp = {"x": [11.0, 12.0], "y": ("a", "b", "c")}    #Simple Dictionary

pp.__class__ is dict                              #same as type() (Avoid)

type(pp) is dict                                  #type() (Strict)

isinstance(pp, dict)                              #isinstance() allows subtypes

isinstance(False, int)                            #bool is a subtype of int
type(False) is int                                #But type() is strict

```


## Basic

- Empty R `list` & Empty Python `dict`

```{r 'R-List-6', decorate=TRUE}
aa <- list("a" = 11L, "b" = 22L)                  #Simple List
str(aa)

bb <- setNames(as.list(c(11L, 22L, 33L)), nm = c("a", "b", "c")) #Named List
str(bb)

# R List equality comparison is order sensitive (unlike Python Dictionary)
dd <- list("b" = 22L, "a" = 11L)
stopifnot(!identical(aa, dd))                     #Order Sensitive
stopifnot(identical(aa[order(names(aa))], dd[order(names(dd))])) #Sort, Compare

ee <- list("c" = 33L, "b" = 999L)
xx <- c(aa, ee)                         #Merge, keep duplicates (Avoid)
str(xx)
xx <- modifyList(aa, val = ee)          #Merge, overwrite duplicates
str(xx)
xx <- within(xx, rm("b"))               #Delete, Key not found Error
xx[c("b")] <- NULL                      #Delete, No Key error
xx <- xx[setdiff(names(xx), "bb")]      #Delete, No Key error
str(xx)

# Merge, overwrite duplicates: This may result in position change of key
str(c(aa, ee)[!duplicated(c(names(aa), names(ee)), fromLast = TRUE)])

ff <- modifyList(aa, val = ee)          #Merge, overwrite duplicates
ff$b <- 22L
stopifnot(identical(bb, ff))
```

```{python 'Y-Dict', decorate=TRUE}
pp = {}                                           #Empty Dictionary
print(f"{type(pp) = } | {len(pp) = } | {pp = }")
pp = {"a": 11, "b": 22}                           #Simple Dictionary
print(f"{len(pp)=}, {pp = }")

qq = {zip(["a", "b", "c"], [11, 22, 33])}         #zip() creates set with {}
assert(type(qq) is set)
qq = dict(zip(["a", "b", "c"], [11, 22, 33]))     #zip() needs dict()
print(f"{len(qq)=}, {qq = }")

# Python Dictionary equality comparison is order insensitive (unlike R List)
ss = {"b": 22, "a": 11}
assert(pp == ss)                                  #Ignore Key Position
assert(not(list(ss.items()) == list(pp.items()))) #Consider Key Position

tt = {"c": 33, "b": 999}
pp.update(tt)                           #Merge in-place, Last seen overwrite
print(f"{len(pp)=}, {pp = }")
pp.update({"b": 22}) 
del pp["c"]                   #Delete in-place, return None, Key not found Error
tt.pop("b")                   #Pop in-place, return value, Key not found Error
tt.pop("b", None)             #Pop in-place, return value, No Key error
tt["b"] = 999                           #Add element using subscript notation
print(f"{len(pp)=}, {pp = }")
print(f"{len(tt)=}, {tt = }")

uu = {**pp, **tt, **{"b": 22}}          #Merge using **, Last seen overwrite
assert(qq == uu)

vv = pp | tt | {"b": 22}                #Merge using | , Last seen overwrite
assert(qq == vv)

ww = copy.deepcopy(pp)
ww |= tt                      #Update in-place using |= , Last seen overwrite
ww |= {"b": 22}
assert(qq == ww)

```

```{r 'R-Compare-List-Dict', decorate=TRUE, include=FALSE}
bb_y <- py$qq                           #Convert Python dictionary to R List
str(bb_y)
stopifnot(identical(bb, bb_y))          #These are Identical
```

```{python 'Y-Compare-List-Dict', decorate=TRUE, include=FALSE}
qq_r = r.bb                             #Convert R List to Python dictionary
print(f"{len(qq_r)=}, {qq_r = }")
assert(qq == qq_r)                      #These are Identical

```

## Nested

```{r 'R-List-Nest', decorate=TRUE}
aa <- list("a" = 11L, "b" = 22L)
bb <- list("c" = 33L, "d" = 44L, "e" = aa)         #Nested List
str(bb)

```

```{python 'Y-Dict-Nest', decorate=TRUE}
pp = {"a": 11, "b": 22}
qq = {"c": 33, "d": 44, "e": pp}                  #Nested Dictionary
print(f"{len(qq)=}, {qq = }")

```

```{r 'R-Compare-List-Dict-Nest', decorate=TRUE, include=FALSE}
bb_y <- py$qq                           #Convert Python dictionary to R List
str(bb_y)
stopifnot(identical(bb, bb_y))          #These are Identical
```

```{python 'Y-Compare-List-Dict-Nest', decorate=TRUE, include=FALSE}
qq_r = r.bb                             #Convert R List to Python dictionary
print(f"{len(qq_r)=}, {qq_r = }")
assert(qq == qq_r)                      #These are Identical

```

## With Multiple DataTypes

```{r 'R-List-Multi', decorate=TRUE}
aa_lst <- list(11L, 22L)                #Unnamed List   | Tuple
bb_lst <- list(a = 11L, b = 22L)        #Named List     | Dict
dd_vec <- c(11L, 22L)                   #Unnamed Vector | List

ee <- list(a = 11L, b = "x", c = FALSE, d = NULL, 
           e = aa_lst, f = dd_vec, g = bb_lst)
```

```{python 'Y-Dict-Multi', decorate=TRUE}
# Exclude Python sets because these are converted to R Environment
#tt_set = {11, 22}            #Set: Unordered, Mutable
pp_tup = (11, 22)             #Tuple: Ordered, Immutable | Unnamed List
qq_lst = [11, 22]             #List: Ordered, Mutable    | Unnamed Vector
ss_dic = {"a": 11, "b": 22}   #Dict: Ordered, Mutable    | Named List

uu = {"a": 11, "b": "x", "c": False, "d": None, 
      "e": pp_tup, "f": qq_lst, "g": ss_dic}
print("\n".join([k + " : " + str(type(uu[k]).__name__) + " : " + str(v) 
                for k, v in uu.items()]))

```

```{r 'R-Compare-List-Dict-Multi', decorate=TRUE, include=FALSE}
ee_y <- py$uu                           #Convert Python dictionary to R List
str(ee_y)
stopifnot(identical(ee, ee_y))          #These are Identical
```

```{python 'Y-Compare-List-Dict-Multi', decorate=TRUE, include=FALSE}
uu_r = r.ee                             #Convert R List to Python dictionary
uu_r["e"] = tuple(uu_r["e"])            #List to Tuple
print("\n".join([k + " : " + str(type(uu_r[k]).__name__) + " : " + str(v) 
                for k, v in uu_r.items()]))
assert(uu == uu_r)                      #These are Identical

```


