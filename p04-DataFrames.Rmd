# Data Frame {#df-p04}

```{r 'setup', include=FALSE}
source("_common.R")
```

## Basics

> Indexing starts from 1 in R and from 0 in Python.  

R provides `data.frame()` for tabular data structure. `{tibble}` & `{data.table}` are packages which extends its capabilities. Python module `r q_link("{pandas}")` provide similar capabilities

R `data.frame()` is a `list()` of variables of the same number of rows. It is a `matrix()` like structure whose columns may be of differing types. Similarly, Python Pandas `r q_link("pd.DataFrame()")` is a 2-dimensional data structure that can store data of different types in columns. 


- Create R `data.frame()`, `tibble::tibble()` and Python `r q_link("pd.DataFrame()")`

```{r 'R-DF-Create', decorate=TRUE}
nn <- 4L                                          #Number of Rows

# R Data Frame: integer, double, character, logical, factor
df_r <- data.frame(
  INT = 1:nn, NUM = seq(1, nn, 1), CHR = letters[1:nn], LGL = (1:nn %% 2) == 0, 
  FCT = factor(rep(c('No', 'Yes'), length.out = nn)))

# Tibble
tbl <- tibble::tibble(
  INT = 1:nn, NUM = seq(1, nn, 1), CHR = letters[1:nn], LGL = (1:nn %% 2) == 0, 
  FCT = factor(rep(c('No', 'Yes'), length.out = nn)))

stopifnot(all(identical(df_r, as.data.frame(tbl)), 
              identical(tbl, tibble::as_tibble(df_r))))
```

```{python 'Y-DF-Create', decorate=TRUE}
pp = 4                                            #Number of Rows

qq = {'INT': [i+1 for i in range(pp)], 
      'NUM': (float(i+1) for i in range(pp)),
      'CHR': [chr(i) for i in range(ord('a'), ord('a') +pp)],
      'LGL': [i % 2 == 1 for i in range(pp)],
      'FCT': pd.Categorical(['No', 'Yes'] * 2)}

df_y = pd.DataFrame(data = qq)                    #DataFrame from dict

```

```{r 'R-Compare', decorate=TRUE, include=FALSE}
# Verify that R Object and Python Variable are similar
aa <- py$df_y |> `attr<-`('pandas.index', NULL)
aa$INT <- as.integer(aa$INT)
stopifnot(identical(df_r, aa))
```

- Print DataFrame: 
  - R: `print()`, `head()`, `tail()`, `dplyr::slice()`
  - Python: `r q_link("print()")`, `r q_link("pd.DataFrame.head()")`, `r q_link("pd.DataFrame.tail()")`, `r q_link("pd.DataFrame.iloc")`

```{r 'R-DF-Head', decorate=TRUE}
aa <- df_r
if(FALSE) print(aa)                     #Data Frame prints ALL Rows (Avoid)
if(FALSE) print(tbl, n = 2)             #Tibble can take number of rows to print

stopifnot(identical(dplyr::slice(aa, 1:2), head(aa, 2)))
head(aa, 2)                                       #Subset by Head

tail(aa, 2)                                       #Subset by Tail
```

```{python 'Y-DF-Head', decorate=TRUE}
pp = df_y.copy()

assert(pp.head(2).equals(pp.iloc[:2]))
pp.head(2)


pp.tail(2)

```

- About DataFrame:
  - R: `class()`, `typeof()`, `dim()`, `names()`, `str()`, `summary()`
  - Python: `r q_link("type()")`, `r q_link("pd.DataFrame.shape")`, `r q_link("pd.DataFrame.columns")`, `r q_link("pd.DataFrame.describe()")`, `r q_link("pd.DataFrame.dtypes")`, `r q_link("pd.DataFrame.info()")`

```{r 'R-DF-About', decorate=TRUE}
aa <- df_r
class(aa)                                         #Class

typeof(aa)                                        #Type

dim(aa)                                           #Dimensions [Row, Column]

names(aa)                                         #Column Headers
```

```{python 'Y-DF-About', decorate=TRUE}
pp = df_y.copy()

print(type(pp))                                   #Explicitly Print type()


pp.shape                                          #Dimensions [Row, Column]


list(pp.columns)                                  #Column Headers
```

```{r 'R-DF-Structure', decorate=TRUE}
aa <- df_r
str(aa)                                           #Structure

summary(aa)                                       #Summary
```

```{python 'Y-DF-Structure', decorate=TRUE}
pp = df_y.copy()
list(pp.describe().index)                         #(Default) Summary of Num only
[x for x in pp.describe(include = 'all').index if x not in pp.describe().index]

pp.describe(include = 'all').loc[['count', 'max', 'unique']]


pp.dtypes                                         #data type of each column


pp.info(memory_usage = False)                     #Structure
```

```{python 'Y-DF-PrintMax', decorate=TRUE}
#Prevent the collapse of middle rows or columns into (...)
if(False):
    with pd.option_context('display.max_rows', None, 
                           'display.max_columns', None):
        print(pp.describe(include = 'all'))

```

- Select Columns:
  - R: `[]` (`base::Extract`), `dplyr::select()`, `data.frame()`, `with()`, `subset()` (Avoid)
  - Python: `r q_link("pd.[]")`, `r q_link("pd.DataFrame.drop()")`, `r q_link("pd.DataFrame.filter()")`

```{r 'R-DF-Select', decorate=TRUE}
aa <- df_r
names(aa)

bb <- dplyr::select(aa, 2:3)                                #Select by Position
dd <- select(aa, NUM, CHR)                                  #Select by Name
ee <- select(aa, -c(INT, LGL, FCT))                         #Drop Columns

ff <- data.frame('NUM' = aa$NUM, 'CHR' = aa$CHR)
# with() can be used to create an environment using data
gg <- with(aa, data.frame(NUM, CHR))
# [] is used for subsetting but note that 1-column subset is vector by default
hh <- aa[ , c('NUM', 'CHR'), drop = FALSE]
ii <- subset(aa, select = c(NUM, CHR), drop = FALSE)        #Avoid

stopifnot(all(sapply(list(dd, ee, ff, gg, hh, ii), identical, bb)))
str(bb)
```

```{python 'Y-DF-Select', decorate=TRUE}
pp = df_y.copy()
list(pp.columns)

qq = pp[['NUM', 'CHR']].copy()                              #Use List of Names
ss = pp.drop(columns = ['INT', 'LGL', 'FCT']).copy()        #Drop Columns
tt = pp.drop(['INT', 'LGL', 'FCT'], axis = 1).copy()        #0 Rows, 1 Columns
uu = pp.filter(['NUM', 'CHR']).copy()

assert(qq.equals(ss) and qq.equals(tt) and qq.equals(uu))
qq

```

- Rename:
  - R: `names()`, `dplyr::rename()`
  - Python: `r q_link("pd.DataFrame.rename()")`, `r q_link("pd.DataFrame.columns")`

```{r 'R-DF-Rename', decorate=TRUE}
aa <- df_r
names(aa)

names(aa)[c(1, 3)] <- c('A', 'C')                 #By Position
names(aa)[names(aa) == 'NUM'] <- 'B'              #By Name

aa <- dplyr::rename(aa, D = LGL, E = 5)           #New = Old (Reverse of Python)
names(aa)
```

```{python 'Y-DF-Rename', decorate=TRUE}
pp = df_y.copy()
list(pp.columns)


pp.rename(columns = {'INT': 'A', pp.columns[1]: 'B'}, inplace = True) #Old: New
pp.rename(columns = dict(zip(pp.columns[[3]], ['D'])),inplace = True) #Old, New
pp.columns.values[[2, 4]] = ['C', 'E']

list(pp.columns)

```

- Sort:
  - R: `order()`, `dplyr::arrange()`, `dplyr::desc()`
  - Python: `r q_link("pd.DataFrame.index")`

```{r 'R-DF-Order', decorate=TRUE}
aa <- df_r

# order() ALWAYS reorders the rownames
bb <- aa[order(aa$CHR, decreasing = TRUE), ]

# arrange() reorders character rownames but reinitialises them from 1 if integer
dd <- dplyr::arrange(aa, dplyr::desc(CHR))
row.names(dd) <- 4:1
stopifnot(identical(bb, dd))
dd
```

```{python 'Y-DF-Order', decorate=TRUE}
pp = df_y.copy()
list(pp.index)


pp.sort_values('CHR', ascending = False, inplace = True)
list(pp.index)

```

## RowNames - Index

- R `row.names()` are called `r q_link("pd.Index")` in Python and can be set by `r q_link("pd.DataFrame.set_index()")`
- R `data.frame()` has `row.names()` but `{tibble}` heavily discourage their usage
- Duplicated row indices are allowed in Python but not in R

```{r 'R-DF-RowNames', decorate=TRUE}
aa <- data.frame(x = 1:2)
row.names(aa)

row.names(aa) <- letters[1:2]                               #rownames

stopifnot(tibble::has_rownames(aa))
row.names(aa)
```

```{python 'Y-DF-RowNames', decorate=TRUE}
pp = pd.DataFrame(data = {'x': [1, 2]})
list(pp.index)


pp.set_index([pd.Index(['a', 'a'])], inplace = True)        #Duplicate index
pp.set_index([pd.Index(['a', 'b'])], inplace = True)
list(pp.index) 

```

## Copy

- For details [see here](#copy-p01)
- Python: For `deepcopy` of `DataFrame` either use `r q_link("{lib.copy}")` or `r q_link("pd.DataFrame.copy()")`

```{r 'R-DF-Copy', decorate=TRUE}
george <- fred <- data.frame(x = 11:13)                     #R Copy-on-Modify

# Before modification both bind to the same address (unlike Python)
stopifnot(identical(obj_addr(fred), obj_addr(george)))

aa <- obj_addr(fred)                    #Address before modification

fred[2, 'x'] <- NA                      #Modify
fred$x

stopifnot(obj_addr(fred) != aa)     #Bind to a different address (unlike Python)

# No change in non-modified object (george) address or value (same as Python)
stopifnot(obj_addr(george) == aa)
```

```{python 'Y-DF-Copy', decorate=TRUE}
fred = pd.DataFrame({'x': [1, 2, 3]})
george = fred.copy()                              #Deepcopy by default
percy  = copy.deepcopy(fred)                      #Deepcopy

# Deepcopy bind to different address even before modification (unlike R)
assert(id(fred) != id(george) != id(percy))

pp = id(fred)                           #Address before modification

fred.at[1, 'x'] = None                  #Modify
list(fred['x'])


assert(id(fred) == pp)                  #No change in address (unlike R)

# No change in non-modified objects (george, percy) address or value (same as R)
assert(george.equals(percy) and not george.equals(fred))

```

## Modify 

- R `[]` (`base::Extract`) 
- Python:
  - `r q_link("pd.DataFrame.at")` can only access a single value at a time (faster). It tries to maintain the datatype (fails sometimes). If column number is used by mistake, it creates a New Column (Avoid)
  - `r q_link("pd.DataFrame.loc")` can select multiple rows and/or columns (slower). It does not maintain the datatype and modifies the type silently.
  - `r q_link("pd.DataFrame.iat")`, `r q_link("pd.DataFrame.iloc")` are indices variants of the above

```{r 'R-DF-Modify', decorate=TRUE}
aa <- df_r
aa[1, 2] <- NA
aa[2, 'CHR'] <- NA
aa
```

```{python 'Y-DF-Modify', decorate=TRUE}
pp = df_y.copy()
pp.at[0, 'NUM'] = None
pp.loc[1, 'CHR'] = None
pp.iat[3, 1] = 10.0
pp.iloc[2, 0] = 30
pp

```

## Verify

```{r 'R-Verify', decorate=TRUE, include=FALSE, eval=FALSE}
# List of URL of this Page
q_url[ , "URL"]

```
