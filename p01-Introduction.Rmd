# Introduction {#introduction-p01}

```{r 'setup', include=FALSE}
################################################################################
source("_common.R")
if(TRUE) lapply(c("lobstr"), 
                FUN = \(x) library(x, character.only = TRUE))
```

## Similarity between R and Python

- Both R and Python are case-sensitive
- Both R and Python use the Hash Sign "#" to comment out anything after it, till the newline
- Both R and Python keep the Backslash "\\" as reserved to escape the character that follows it


## Differences between R and Python

### Indentation

- Indentation and white spaces are extremely significant in Python (unlike R)
  - 4 Spaces (not Tab) are being used, in this book, for Python chunks
  - A backslash "\\" allows you to break up one long piece of code into several parts
  - Any character (including whitespace) after the backslash will cause an error
  - Parentheses "()" can be used to enclose all of the code. Parentheses work like the backslash, but allow extra characters at the end
  - An extra newline is being added in Python chunks, in this book, to indicate that the command /block has been completed

### Boolean

- R (TRUE, FALSE) vs. Python (True, False) - Case is different

### NULL & None

- `NULL` represents the null object in R: it is a reserved word. NULL is often returned by expressions and functions whose value is undefined. 
  - There is only one null object in memory
  - Inside if condition, NULL throws error, use 'is.null(x)' syntax
- Python uses the keyword `None` to define null objects and variables
  - Inside if condition, None acts as False, use 'x is None' syntax
  - None is a singleton. There is only one None in memory
  - [Real Python](https://realpython.com/null-in-python/)

```{r 'R-NULL', decorate=TRUE}
# Return of str() is NULL which is passed to print()
print(str("This returns NULL in R"))

# Assign NULL
aa <- NULL
# Type
typeof(aa)
# Check
is.null(aa)

# A name pointing to NULL is different from a name which does not exist 'bb'
exists("aa")
exists("bb")
tryCatch(expr = print(bb), error = \(e) print(e))

# Usage inside if conditional: NULL throws Error, use is.null()
if(is.null(aa)) {
  print("IF Block") 
} else {
  print("ELSE Block")
}
```

```{python 'Y-None', decorate=TRUE}
# Return of print() is None which is passed to print()
print(print("This returns None in Python"))

# Assign None
pp = None
# Type
type(pp)
# Check
pp is None

# A name pointing to None is different from a name which does not exist 'qq'
'pp' in globals()
'qq' in globals()
try:
    print(qq)
except NameError as e:
    print(e) #e.args type(e)

#
# Usage inside if conditional: None is falsy (taken as FALSE), use 'is None' 
if(pp):
    print("IF Block")
else:
    print("ELSE Block")

#
```


### Indexing

- Indexing starts at 1 in R. Whereas, it starts at 0 in Python

### Pipe

- Python uses dot "." as pipe operator
- R uses "|>" as pipe operator along with underscore "_" as placeholder
  - To minimize the issues, in this book, underscore will be used (and dot will be avoided) in names of objects or variables names

### Assignment Operator

- Python uses 'equal to' " = " as assignment operator 
- R uses 'left arrow' " <- " as assignment operator
  - In R, while the " = " can be used for assignment, its usage for assignment is highly discouraged because it may behave differently under certain subtle conditions which are difficult to debug
  - Convention is to use " = " only during function calls for arguments association (syntactic token)

### Copy Objects or Variables

- R [Advanced R, Hadley](https://adv-r.hadley.nz/names-values.html "https://adv-r.hadley.nz/names-values.html")

- Python Similar but different
  
```{r 'R-Copy', decorate=TRUE}
# Load Packages: "lobstr"
# Create an object containing a value and bind that object to name 'aa'
aa <- 10 
# Copy an object i.e. Create another binding to an already existing value
bb <- aa
# Note that both names are pointing to same memory address
obj_addr(aa)
obj_addr(bb)
stopifnot(identical(obj_addr(aa), obj_addr(bb)))

# Print the copy
print(bb)
# Modify the copy
bb <- 5
# Print the copy and the original (original is unmodified)
print(bb)
print(aa)
# Now the modified name points to a different memory address than earlier
obj_addr(bb)
# Original is still pointing to the same address containing original object
obj_addr(aa)
```

```{python 'Y-Copy', decorate=TRUE}
# Create a variable containing a value and bind that variable to name 'pp'
pp = 10 
# Copy a variable i.e. Create another binding to an already existing value
qq = pp
# Note that both names are pointing to same memory address
id(pp)
id(qq)
assert(id(pp) == id(qq))

# Print the copy
print(qq)
# Modify the copy
qq = 5
# Print the copy and the original (original is unmodified)
print(qq)
print(pp)
# Now the modified name points to a different memory address than earlier
id(qq)
# Original is still pointing to the same address containing original variable
id(pp)

```

### Reticulate Type conversion

- R : Python
- Single element vector : Scalar
- Multi element vector : List
- List of multiple types : Tuple
- Named List : Dictionary
- Matrix /Array : NumPy ndarray
- Data Frame : Pandas Data Frame
- Function: Function
- Raw : Byte array

## Verify

```{r 'R-Version', decorate=TRUE}
R.version.string
```

```{python 'Y-Version', decorate=TRUE}
print(sys.version.split()[0])

```

```{r 'R-List-Objects', decorate=TRUE}
ls()
```
