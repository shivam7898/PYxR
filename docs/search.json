[{"path":"index.html","id":"welcome","chapter":"Welcome","heading":"Welcome","text":"book compare contrast Python R using minimum working examples (MWE).","code":""},{"path":"index.html","id":"license","chapter":"Welcome","heading":"License","text":"code samples book licensed Creative Commons CC0 1.0 Universal (CC0 1.0), .e. public domain.","code":""},{"path":"preface.html","id":"preface","chapter":"Preface","heading":"Preface","text":"","code":""},{"path":"preface.html","id":"guidelines","chapter":"Preface","heading":"0.1 Guidelines","text":"project kept sync latest versions Python R.ensured code can executed direct copy-paste without significantly affecting user work environmentEquality & Identity tests related language rules may hidden avoid clutter","code":""},{"path":"preface.html","id":"references","chapter":"Preface","heading":"0.2 References","text":"CRAN R Manuals CRAN Duplicate :\nIntroduction R\nR Installation Administration\nR Data Import/Export\nWriting R Extensions\nR Internals\nR Language Definition\nR FAQ\nIntroduction RR Installation AdministrationR Data Import/ExportWriting R ExtensionsR InternalsR Language DefinitionR FAQPython :\nPython Standard Library\nPython Language Reference\nPython Tutorial\nPython HOWTO\nPython Standard LibraryPython Language ReferencePython TutorialPython HOWTO","code":""},{"path":"preface.html","id":"prerequisites","chapter":"Preface","heading":"0.3 Prerequisites","text":" R Python","code":"\nstrsplit(R.version.string, \" \")[[1]][3]           # R Version\n## [1] \"4.2.1\"print(sys.version.split()[0])                     # Python Version\n## 3.10.5"},{"path":"preface.html","id":"environment","chapter":"Preface","heading":"0.4 Environment","text":" R Python R","code":"\n# Attached (Basic) Packages in R \nsessionInfo()\n## R version 4.2.1 (2022-06-23 ucrt)\n## Platform: x86_64-w64-mingw32/x64 (64-bit)\n## Running under: Windows 10 x64 (build 19044)\n## \n## Matrix products: default\n## \n## locale:\n## [1] LC_COLLATE=English_India.utf8  LC_CTYPE=English_India.utf8   \n## [3] LC_MONETARY=English_India.utf8 LC_NUMERIC=C                  \n## [5] LC_TIME=English_India.utf8    \n## \n## attached base packages:\n## [1] stats     graphics  grDevices datasets  utils     methods   base     \n## \n## other attached packages:\n## [1] fontawesome_0.2.2 reticulate_1.25   knitr_1.39        conflicted_1.1.0 \n## \n## loaded via a namespace (and not attached):\n##  [1] Rcpp_1.0.8.3    rstudioapi_0.13 magrittr_2.0.3  xml2_1.3.3     \n##  [5] downlit_0.4.1   lattice_0.20-45 here_1.0.1      R6_2.5.1       \n##  [9] rlang_1.0.3     fastmap_1.1.0   stringr_1.4.0   tools_4.2.1    \n## [13] grid_4.2.1      xfun_0.31       png_0.1-7       cli_3.3.0      \n## [17] jquerylib_0.1.4 htmltools_0.5.2 yaml_2.3.5      digest_0.6.29  \n## [21] rprojroot_2.0.3 bookdown_0.27   Matrix_1.4-1    fs_1.5.2       \n## [25] sass_0.4.1      memoise_2.0.1   cachem_1.0.6    evaluate_0.15  \n## [29] rmarkdown_2.14  stringi_1.7.6   compiler_4.2.1  bslib_0.3.1    \n## [33] jsonlite_1.8.0# Imported (Basic) Modules in Python \nallmodules = [v.__name__ for k, v in globals().items() \n    if type(v) is types.ModuleType and not k.startswith('__')]\n\nlen(allmodules)                                   # Count the Loaded Modules\n## 8\n\", \".join(allmodules)                             # List Modules\n## 'sys, os, pip, copy, types, math, pandas, numpy'\n# Python Configuration with R Package 'Reticulate'\npy_config()\n## python:         C:/Softwares/Python/Python310/python.exe\n## libpython:      C:/Softwares/Python/Python310/python310.dll\n## pythonhome:     C:/Softwares/Python/Python310\n## version:        3.10.5 (tags/v3.10.5:f377153, Jun  6 2022, 16:14:13) [MSC v.1929 64 bit (AMD64)]\n## Architecture:   64bit\n## numpy:          C:/Softwares/Python/Python310/Lib/site-packages/numpy\n## numpy_version:  1.23.0\n## \n## NOTE: Python version was forced by use_python function"},{"path":"introduction-p01.html","id":"introduction-p01","chapter":"1 Introduction","heading":"1 Introduction","text":"","code":""},{"path":"introduction-p01.html","id":"basics","chapter":"1 Introduction","heading":"1.1 Basics","text":"R Python case-sensitiveBoth R Python case-sensitiveBoth R Python use Hash sign # comment anything , till newlineBoth R Python use Hash sign # comment anything , till newlineBoth R Python keep Backslash \\ reserved escape character follows itBoth R Python keep Backslash \\ reserved escape character follows itRefer ThisRefer ThisIn R & Python, Everything exists object.Indexing starts 1 R. Whereas, starts 0 PythonIndexing starts 1 R. Whereas, starts 0 PythonPeriods . (dots)\nPython, dot . member access operator use access methods object(class instance). Thus, can used pipe chain together multiple operations.\nPython, dot part object name. Whereas, R treat dot special.\nR uses |> pipe operator along underscore _ placeholder\nminimize issues, book, underscore used (dot avoided) names objects variables names\nPeriods . (dots)Python, dot . member access operator use access methods object(class instance). Thus, can used pipe chain together multiple operations.Python, dot part object name. Whereas, R treat dot special.R uses |> pipe operator along underscore _ placeholderTo minimize issues, book, underscore used (dot avoided) names objects variables namesR functions implicitly return last object evaluated. Whereas, Python functions return explicitly .R functions implicitly return last object evaluated. Whereas, Python functions return explicitly .Primer Python R UsersPrimer Python R UsersInformation R Python Users\nR, Methods (Functions) part class definitions. Methods R look class objects may behave differently based .\nEx: summary() numeric vector factor vector different .e. summarised differently. summary() checks class attribute object calls method summarizing objects class.\nSlicing / Subsetting:\nR, start stop values inclusive slicing, unlike Python stop value exclusive.\nR, start stop values specified slicing, unlike Python specify start/stop value refers first/last value respectively.\nDash - (Minus) acts reverse index Python, whereas R removes specified elements\n\nInformation R Python UsersIn R, Methods (Functions) part class definitions. Methods R look class objects may behave differently based .Ex: summary() numeric vector factor vector different .e. summarised differently. summary() checks class attribute object calls method summarizing objects class.Slicing / Subsetting:\nR, start stop values inclusive slicing, unlike Python stop value exclusive.\nR, start stop values specified slicing, unlike Python specify start/stop value refers first/last value respectively.\nDash - (Minus) acts reverse index Python, whereas R removes specified elements\nR, start stop values inclusive slicing, unlike Python stop value exclusive.R, start stop values specified slicing, unlike Python specify start/stop value refers first/last value respectively.Dash - (Minus) acts reverse index Python, whereas R removes specified elements","code":""},{"path":"introduction-p01.html","id":"braces-indentation","chapter":"1 Introduction","heading":"1.2 Braces & Indentation","text":"R uses braces {} group expressions code blocks ignores indentationIndentation white spaces extremely significant Python (unlike R)\n4 Spaces (Tab) used, book, Python chunks\nbackslash \\ allows break one long piece code several parts\ncharacter (including whitespace) backslash cause error\nParentheses () can used enclose code. Parentheses work like backslash, allow extra characters end\n4 Spaces (Tab) used, book, Python chunksA backslash \\ allows break one long piece code several partsAny character (including whitespace) backslash cause errorParentheses () can used enclose code. Parentheses work like backslash, allow extra characters end","code":""},{"path":"introduction-p01.html","id":"mathematical-operators","chapter":"1 Introduction","heading":"1.3 Mathematical Operators","text":"R Python following operators:\nAddition +, Subtraction -, Multiplication *, Division /\nExponent given caret ^ ** R ** Python\nPython uses caret bitwise XOR\n\nModulus (Remainder) given %% R % Python\nPython uses %% escape percent sign strings\nR use standalone % operator (except special cases like sprintf())\nHowever, R uses %...% syntax define special operators (infix operators) like %*%, %%, etc.\n\nInteger Division (Quotient) given %/% R // Python\nPython use %/% R use //\n\nAddition +, Subtraction -, Multiplication *, Division /Exponent given caret ^ ** R ** Python\nPython uses caret bitwise XOR\nPython uses caret bitwise XORModulus (Remainder) given %% R % Python\nPython uses %% escape percent sign strings\nR use standalone % operator (except special cases like sprintf())\nHowever, R uses %...% syntax define special operators (infix operators) like %*%, %%, etc.\nPython uses %% escape percent sign stringsR use standalone % operator (except special cases like sprintf())However, R uses %...% syntax define special operators (infix operators) like %*%, %%, etc.Integer Division (Quotient) given %/% R // Python\nPython use %/% R use //\nPython use %/% R use // R Python","code":"\n# Exponent\n5 ** 3\n## [1] 125\n5 ^ 3\n## [1] 125\n\n5 %% 3    # Modulus (Remainder)\n## [1] 2\n5 %/% 3   # Integer Division (Quotient)\n## [1] 1# Exponent\n5 ** 3\n## 125\n5 % 3     # Modulus (Remainder)\n## 2\n5 // 3    # Integer Division (Quotient)\n## 1"},{"path":"introduction-p01.html","id":"help","chapter":"1 Introduction","heading":"1.4 Help","text":"R Python help() get details topic\nR also shorthand get help prefixing ? topic\nR also shorthand get help prefixing ? topic R Python","code":"\nif(FALSE) {\n  help(print)\n  ?print\n  ?`+`\n}if(False):\n    help(print)"},{"path":"introduction-p01.html","id":"print","chapter":"1 Introduction","heading":"1.5 Print","text":"Printing largely handled print() R Python\nExplicit Implicit types printing available\nExplicit Implicit types printing available","code":""},{"path":"introduction-p01.html","id":"na-nan-00---nan","chapter":"1 Introduction","heading":"1.6 NA NaN 0/0 - nan","text":"0/0 NaN (Number) R undefined Python\nIEEE754 standard defines three special floating-point numbers, Inf, -Inf NaN\nNaN ‘well-defined real number’\nnumerical computing, result can written regular real number, Inf -Inf, expressed NaN.\nIEEE754 standard defines three special floating-point numbers, Inf, -Inf NaNNaN ‘well-defined real number’numerical computing, result can written regular real number, Inf -Inf, expressed NaN.NA NaN\nPython distinguish ‘missing values’ ‘number’. whereas, R clearly distinguish NA NaN\nNaN float value, explicit missing values non-float columns. R, NA can type.\nPython distinguish ‘missing values’ ‘number’. whereas, R clearly distinguish NA NaNNaN float value, explicit missing values non-float columns. R, NA can type.Comparison operation NaN (even )\nPython: == returns False, != returns True (IEEE754 Standard)\nR: operations (==, !=, >= <=, >, <) results NA\nR: NA NaN compared anything NA.\nPython: == returns False, != returns True (IEEE754 Standard)R: operations (==, !=, >= <=, >, <) results NAR: NA NaN compared anything NA.Coercion NaN R (Casting Conversion)\nNaN coercion integer gives NA_integer_\nNaN coercion logical gives NA\nNaN coercion numeric gives NaN\nNaN coercion character gives \"NaN\"\nNaN coercion integer gives NA_integer_NaN coercion logical gives NANaN coercion numeric gives NaNNaN coercion character gives \"NaN\"Reticulate:\npython, missing values also NaN\nnp.nan math.nan Python converted NaN R\nNaN R converted NaN Python\npython, missing values also NaNBoth np.nan math.nan Python converted NaN RNaN R converted NaN PythonPandas\nnp.nan math.nan treated ‘missing values’ class numpy.float64\nNone also treated missing value. numeric columns, None converted nan. columns object type, kept None treated missing value.\nexist pd.NA scalar Pandas, similar R NA. However, experimental currently treated np.nan internally. , used now, book.\nnp.nan math.nan treated ‘missing values’ class numpy.float64None also treated missing value. numeric columns, None converted nan. columns object type, kept None treated missing value.exist pd.NA scalar Pandas, similar R NA. However, experimental currently treated np.nan internally. , used now, book. R Python","code":"\n# 0/0 is defined as NaN in R (unlike Python)\nis.nan(NaN)\n## [1] TRUE\nis.nan(0/0)\n## [1] TRUE\n\n# NaN is treated as NA, however, NA is not treated as NaN\nis.na(NaN)\n## [1] TRUE\nis.nan(NA)\n## [1] FALSE\n\n# NaN is numeric\nstopifnot(is.numeric(NaN))\n\n# Comparison with NaN: All operations are NA, use is.nan() (unlike IEEE, Python)\nstopifnot(all(sapply(list(NaN == NaN, NaN <= NaN, NaN >= NaN, \n                          NaN != NaN, NaN <  NaN, NaN >  NaN), identical, NA)))\n\n# Coercion of NaN\nstopifnot(all(identical(as.integer(NaN), NA_integer_),\n              identical(as.logical(NaN), NA),\n              identical(as.character(NaN), \"NaN\"),\n              identical(as.numeric(NaN), NaN)))# 0/0 is undefined in Python (unlike R)\ntry:\n    print(0/0)\nexcept ZeroDivisionError as e:\n    print(e) #e.args type(e)\n\n# There are Two NaN in modules NumPy and Math\n# Use module specific methods but not the 'is' keyword\n## division by zero\npp = float(\"NaN\") # Not case sensitive i.e. NaN, NAN, nan etc. all are valid\nprint(pp)\n## nan\ntype(pp)\n## <class 'float'>\nassert(math.isnan(math.nan) and math.isnan(np.nan) and math.isnan(pp))\nassert(np.isnan(np.nan) and np.isnan(math.nan) and np.isnan(pp))\n\n# 'is' returns True if and only if the two references are to the same object\nnp.nan is math.nan            # False\n\n# Comparison with NaN: == is False, != is True (as per IEEE but unlike R)\n## False\nnp.nan == np.nan\n## False\nmath.nan == math.nan\n \n## False\nnp.nan != np.nan\n## True\nmath.nan != math.nan\n## True"},{"path":"introduction-p01.html","id":"boolean","chapter":"1 Introduction","heading":"1.7 Boolean","text":"R (TRUE, FALSE) vs. Python (True, False) - Case differentPython:\nvalues considered “truthy” except following, “falsy”\nNone, False, 0, 0.0, 0j, Decimal(0), Fraction(0, 1)\nEmpty: list [], dictionary {}, tuple (), string '', range range(0) etc.\nobjects :\nobj.__bool__() returns False\nobj.__len__() returns 0\n\n“truthy” value satisfy check performed statements.\nuse “truthy” “falsy” differentiate bool values True False.\nPython determines truthiness applying bool() type, returns True False used expression like .\nInstances user-defined class considered truthy default.\n\n\nvalues considered “truthy” except following, “falsy”\nNone, False, 0, 0.0, 0j, Decimal(0), Fraction(0, 1)\nEmpty: list [], dictionary {}, tuple (), string '', range range(0) etc.\nobjects :\nobj.__bool__() returns False\nobj.__len__() returns 0\n\n“truthy” value satisfy check performed statements.\nuse “truthy” “falsy” differentiate bool values True False.\nPython determines truthiness applying bool() type, returns True False used expression like .\nInstances user-defined class considered truthy default.\n\nNone, False, 0, 0.0, 0j, Decimal(0), Fraction(0, 1)Empty: list [], dictionary {}, tuple (), string '', range range(0) etc.objects :\nobj.__bool__() returns False\nobj.__len__() returns 0\nobj.__bool__() returns Falseobj.__len__() returns 0A “truthy” value satisfy check performed statements.use “truthy” “falsy” differentiate bool values True False.Python determines truthiness applying bool() type, returns True False used expression like .\nInstances user-defined class considered truthy default.\nInstances user-defined class considered truthy default.","code":""},{"path":"introduction-p01.html","id":"logical-operators","chapter":"1 Introduction","heading":"1.8 Logical Operators","text":"R Python short-circuit evaluationBoth R Python short-circuit evaluationR uses &, && indicate logical |, || indicate logical .\nR use ‘’ ‘’\nshorter operators (&, |) vectorized. Given two vectors, logically compare pairs elements vector.\nOutput length equal length longer vector using vector recycling\nWarning: longer object length multiple shorter object length trigger lengths vector multiple .\n() () can used reduce length logical vector one\n\ncontrast, longer operators (&&, ||) work length-one vectors.\nlonger form appropriate programming control-flow typically preferred \nclauses.\nOutput always vector length 1.\nlength either vector one, currently (R 4.2.1), Warning: 'length(x) = 2 > 1' coercion 'logical(1)' triggers next R release, converted Error.\nCurrently (R 4.2.1), comparison happen first elements vector.\n\nShort-circuit:\nR evaluate second operand && || can learn answer first operand (Left First).\nHowever, shorter operators (&, |) short-circuit\n\nNA similarly handled shorter longer operators\nNA either TRUE FALSE change outcome, value returned, otherwise NA returned. case can read ‘determined’.\nisTRUE() isFALSE() can used convert NA TRUE FALSE\n\nRefer \nR uses &, && indicate logical |, || indicate logical .R use ‘’ ‘’shorter operators (&, |) vectorized. Given two vectors, logically compare pairs elements vector.\nOutput length equal length longer vector using vector recycling\nWarning: longer object length multiple shorter object length trigger lengths vector multiple .\n() () can used reduce length logical vector one\nOutput length equal length longer vector using vector recyclingWarning: longer object length multiple shorter object length trigger lengths vector multiple .() () can used reduce length logical vector oneIn contrast, longer operators (&&, ||) work length-one vectors.\nlonger form appropriate programming control-flow typically preferred \nclauses.\nOutput always vector length 1.\nlength either vector one, currently (R 4.2.1), Warning: 'length(x) = 2 > 1' coercion 'logical(1)' triggers next R release, converted Error.\nCurrently (R 4.2.1), comparison happen first elements vector.\nlonger form appropriate programming control-flow typically preferred \nclauses.Output always vector length 1.length either vector one, currently (R 4.2.1), Warning: 'length(x) = 2 > 1' coercion 'logical(1)' triggers next R release, converted Error.Currently (R 4.2.1), comparison happen first elements vector.Short-circuit:\nR evaluate second operand && || can learn answer first operand (Left First).\nHowever, shorter operators (&, |) short-circuit\nR evaluate second operand && || can learn answer first operand (Left First).However, shorter operators (&, |) short-circuitNA similarly handled shorter longer operators\nNA either TRUE FALSE change outcome, value returned, otherwise NA returned. case can read ‘determined’.\nisTRUE() isFALSE() can used convert NA TRUE FALSE\nNA either TRUE FALSE change outcome, value returned, otherwise NA returned. case can read ‘determined’.isTRUE() isFALSE() can used convert NA TRUE FALSERefer ThisPython uses indicate logical indicate logical .\nPython uses & | bitwise comparison\nPython, lazy whereas & | \nPython uses indicate logical indicate logical .Python uses & | bitwise comparisonIn Python, lazy whereas & | R Python","code":"\n# Only the First expression is evaluated if it is enough to determine the result\nTRUE | NaN\n## [1] TRUE\nFALSE & NaN\n## [1] FALSE\n\n# Here the Second expression is also evaluated because first is not sufficient\nTRUE & NaN\n## [1] NA\nFALSE | NaN\n## [1] NA\n\n# Logical evaluation returns TRUE, FALSE or NA in R (unlike Python)\n# 0 is FALSE\n3 | NaN\n## [1] TRUE\n0 & NaN\n## [1] FALSE\n0 | NaN\n## [1] NA# Only the First expression is evaluated if it is enough to determine the result\nTrue or np.nan\n## True\nFalse and np.nan\n\n# Here the Second expression is also evaluated because first is not sufficient\n## False\nTrue and np.nan \n## nan\nFalse or np.nan\n\n# Logical evaluation returns the value of final expression evaluated (unlike R)\n## nan\n3 or np.nan\n## 3\nTrue and 3\n## 3"},{"path":"introduction-p01.html","id":"null---none","chapter":"1 Introduction","heading":"1.9 NULL - None","text":"NULL represents null object R: reserved word. NULL often returned expressions functions whose value undefined.\none null object memory\nInside condition, NULL throws error, use .null(x) syntax\noutput expression show numbers brackets like ‘[1]’ NULL type return. [Numbers] show Vector. Ex: str() cat() outputs NULL Type.\none null object memoryInside condition, NULL throws error, use .null(x) syntaxIf output expression show numbers brackets like ‘[1]’ NULL type return. [Numbers] show Vector. Ex: str() cat() outputs NULL Type.Python uses keyword None define null objects variables\nInside condition, None acts False, use x None syntax\nNone singleton. one None memory\nReal Python\nInside condition, None acts False, use x None syntaxNone singleton. one None memoryReal Python R Python","code":"\n# Return of str() is NULL which is passed to print()\nprint(str(\"This returns NULL in R\"))\n##  chr \"This returns NULL in R\"\n## NULL\n\n# Assign NULL\naa <- NULL\n# Type\ntypeof(aa)\n## [1] \"NULL\"\n# Check\nis.null(aa)\n## [1] TRUE\n# is.na() returns logical(0) for NULL\nis.na(aa)\n## logical(0)\n\n# A name pointing to NULL is different from a name which does not exist 'bb'\nexists(\"aa\")\n## [1] TRUE\nexists(\"bb\")\n## [1] FALSE\ntryCatch(expr = print(bb), error = \\(e) print(e))\n## <simpleError in print(bb): object 'bb' not found>\n\n# Usage inside if conditional: NULL throws Error, use is.null()\nif(is.null(aa)) {\n  print(\"Object is NULL\") \n} else {\n  print(\"Object is Not NULL\")\n}\n## [1] \"Object is NULL\"# Return of print() is None which is passed to print()\nprint(print(\"This returns None in Python\"))\n\n# Assign None\n## This returns None in Python\n## None\npp = None\n# Type\ntype(pp)\n# Check\n## <class 'NoneType'>\npp is None\n\n# A name pointing to None is different from a name which does not exist 'qq'\n## True\n'pp' in globals()\n## True\n'qq' in globals()\n## False\ntry:\n    print(qq)\nexcept NameError as e:\n    print(e) #e.args type(e)\n\n#\n# Usage inside if conditional: None is falsy (taken as FALSE), use 'is None' \n## name 'qq' is not defined\nif(pp):\n    print(\"Variable is None\")\nelse:\n    print(\"Variable is Not None\")\n\n#\n## Variable is Not None"},{"path":"introduction-p01.html","id":"assignment-operator","chapter":"1 Introduction","heading":"1.10 Assignment Operator","text":"Python uses ‘equal ’ = assignment operatorR uses ‘left arrow’ <- assignment operator\nR, = can used assignment, usage assignment highly discouraged may behave differently certain subtle conditions difficult debug\nConvention use = function calls arguments association (syntactic token)\nR, = can used assignment, usage assignment highly discouraged may behave differently certain subtle conditions difficult debugConvention use = function calls arguments association (syntactic token)","code":""},{"path":"introduction-p01.html","id":"object-p01","chapter":"1 Introduction","heading":"1.11 Copy Objects or Variables","text":"R, Everything exists object.\nR, Everything happens function call.Refer ()\n‘Everything’ excludes ‘reserved’ keywords can found ?reserved\n“Everything exists R object” sense kind data structure can manipulated.\nThink R objects collections data kinds. data contained way data organized depend class object generated.\nkey concept expressions evaluation objects. Evaluation consists taking object representing expression returning object value expression.\n\n‘Everything’ excludes ‘reserved’ keywords can found ?reserved“Everything exists R object” sense kind data structure can manipulated.\nThink R objects collections data kinds. data contained way data organized depend class object generated.\nkey concept expressions evaluation objects. Evaluation consists taking object representing expression returning object value expression.\nThink R objects collections data kinds. data contained way data organized depend class object generated.key concept expressions evaluation objects. Evaluation consists taking object representing expression returning object value expression.Python, Everything object.means ‘everything’ instance class (almost) everything attributes\n‘Everything’ excludes ‘reserved’ keywords can found help(\"keywords\")\n‘Everything’ excludes ‘reserved’ keywords can found help(\"keywords\")R uses ‘copy--modify’ semantics Advanced R, Hadley\nassignment, two names (e.g. aa, bb) might pointing object address. However, soon object modified, using one name (bb), R creates another copy original points modified name (bb) new address. Unmodified name (aa) keeps pointing original address containing original object. Effectively, deepcopy operation.\nassignment, two names (e.g. aa, bb) might pointing object address. However, soon object modified, using one name (bb), R creates another copy original points modified name (bb) new address. Unmodified name (aa) keeps pointing original address containing original object. Effectively, deepcopy operation.Python mutable immutable objects\nlist, set, dict, numpy arrays, pandas dataframes mutable, modified place .e. append result modification value. Thus, names pointing address show new value. id() names remain .\nnumbers, strings, bool, Tuples, Frozen Sets immutable, new object created modifications apply. Thus, name (used modification) now point different address containing new value. id() name different. names pointing original address keep pointing value, address.\nMany numpy operations modify array place.\n, tuple containing list immutable, however, contains items mutable\n:\nmanipulations immutable types create new objects\nmanipulations mutable types create new objects\nThus, appending something end list -place mutation (existing list changed). slicing : doubling * list creates new lists.\n\n, ‘pass object-reference’ may result impact modification different object names passed function shallow copy name passed .\nVerify case doubt\nlist, set, dict, numpy arrays, pandas dataframes mutable, modified place .e. append result modification value. Thus, names pointing address show new value. id() names remain .numbers, strings, bool, Tuples, Frozen Sets immutable, new object created modifications apply. Thus, name (used modification) now point different address containing new value. id() name different. names pointing original address keep pointing value, address.Many numpy operations modify array place., tuple containing list immutable, however, contains items mutableFurther:\nmanipulations immutable types create new objects\nmanipulations mutable types create new objects\nThus, appending something end list -place mutation (existing list changed). slicing : doubling * list creates new lists.\nmanipulations immutable types create new objectsSome manipulations mutable types create new objectsThus, appending something end list -place mutation (existing list changed). slicing : doubling * list creates new lists., ‘pass object-reference’ may result impact modification different object names passed function shallow copy name passed .Verify case doubt R Python Python","code":"\nif(FALSE) library(\"lobstr\")\n# Create an object containing a value and bind that object to name 'aa'\naa <- 10 \n# Copy an object i.e. Create another binding to an already existing value\nbb <- aa\n# Note that both names are pointing to same memory address\nobj_addr(aa)\n## [1] \"0x1f14469bc68\"\nobj_addr(bb)\n## [1] \"0x1f14469bc68\"\nstopifnot(identical(obj_addr(aa), obj_addr(bb)))\n\n# Print the copy\nprint(bb)\n## [1] 10\n# Modify the copy\nbb <- 5\n# Print the copy and the original (original is unmodified)\nprint(bb)\n## [1] 5\nprint(aa)\n## [1] 10\n# Now the modified name points to a different memory address than earlier\nobj_addr(bb)\n## [1] \"0x1f14469bae0\"\n# Original is still pointing to the same address containing original object\nobj_addr(aa)\n## [1] \"0x1f14469bc68\"# Create a variable containing a value and bind that variable to name 'pp'\npp = 10 \n# Copy a variable i.e. Create another binding to an already existing value\nqq = pp\n# Note that both names are pointing to same memory address\nid(pp)\n## 2135820403216\nid(qq)\n## 2135820403216\nassert(id(pp) == id(qq))\n\n# Print the copy\nprint(qq)\n# Modify the copy\n## 10\nqq = 5\n# Print the copy and the original (original is unmodified)\nprint(qq)\n## 5\nprint(pp)\n# Now the modified name points to a different memory address than earlier\n## 10\nid(qq)\n# Original is still pointing to the same address containing original variable\n## 2135820403056\nid(pp)\n## 2135820403216# Python Lists (mutable) are modified in place i.e. shallow copy is used\npp = [11, 22, 33]             #variable named 'pp' pointing to a list\nqq = pp                       #variable named 'qq' pointing to the same list\nassert(id(pp) == id(qq))      #verify both are pointing to same address\nid(pp)                        #Actual address\n\n# Unlike the string.upper() below, list.append() need not to be assigned \n## 2136066705664\nqq.append(44)\nprint(pp)                     #Original 'pp' is also pointing to modified list\n## [11, 22, 33, 44]\nassert(id(pp) == id(qq))      #both 'pp' & 'qq' still point to same address\nid(pp)                        #Object address has not changed from earlier\n\n# Python Dictionaries (mutable) are also modified in place\n## 2136066705664\npp = {\"a\": 11, \"b\": 22, \"c\": 33}\nqq = pp\nqq[\"d\"] = 44                  #Modify 'qq' by adding another key\nassert(id(pp) == id(qq))      #both 'pp' & 'qq' still point to same address\nprint(pp)                     #Original 'pp' is also pointing to modified dict\n\n# However, Python strings are immutable (like R)\n## {'a': 11, 'b': 22, 'c': 33, 'd': 44}\npp = 'abc'\nqq = pp\nassert(id(pp) == id(qq))\nid(pp)\n\n# Unlike the list.append() above, string.upper() needs to be assigned \n## 2135821688496\nqq.upper()\n## 'ABC'\nassert(id(pp) == id(qq))      #both 'pp' & 'qq' still point to same address\nid(qq)\n## 2135821688496\nprint(qq)                     #'qq' is still pointing to the same object\n## abc\nqq = qq.upper()               #binding the new object created to 'qq'\nid(qq)                        #'qq' now points to a different object\n## 2136103273776\nprint(qq)\n## ABC\nid(pp)                        #Original 'pp' still points to the same address \n## 2135821688496\nprint(pp)                     #with same value\n\n# Mutability (shallow copy) can impact other objects unexpectedly\n## abc\npp = [11, 22, 33]\nqq = pp\n\n# Define Function\ndef append_44(lst):\n    lst.append(44)\n    return lst\n\n# Call function using 'pass by object-reference' for 'pp'\nappend_44(pp)\n\n#However, 'qq' keeps pointing to original address (which now have new values)\n## [11, 22, 33, 44]\nprint(qq)\n## [11, 22, 33, 44]"},{"path":"introduction-p01.html","id":"reticulate-type-conversion","chapter":"1 Introduction","heading":"1.12 Reticulate Type conversion","text":"Refer Table 1.1 conversion rules\nPython variables available R elements py object\nR objects available Python elements r class\nPython variables available R elements py objectR objects available Python elements r classTable 1.1:  (P01T01) Reticulate Type conversion","code":""},{"path":"introduction-p01.html","id":"setup-python-with-reticulate-in-r","chapter":"1 Introduction","heading":"1.13 Setup Python with Reticulate in R","text":" R","code":"\nif(FALSE) {\n  # In R package::reticulate handles Python\n  library(\"reticulate\")\n  \n  # Provide the path to the specific Python binary.\n  use_python(\"C:\\\\Softwares\\\\Python\\\\Python310\\\\python.exe\", required = TRUE)\n  \n  # PATH: C:\\Softwares\\Python\\Python310\\python.exe\n  Sys.which(\"python\")\n}"},{"path":"introduction-p01.html","id":"working-directory","chapter":"1 Introduction","heading":"1.14 Working Directory","text":" R Python","code":"\ngetwd()             # Working Directory\n## [1] \"D:/Analytics/PYxR\"os.getcwd()         # Working Directory\n## 'D:\\\\Analytics\\\\PYxR'"},{"path":"introduction-p01.html","id":"verify-r-python-installation","chapter":"1 Introduction","heading":"1.15 Verify R & Python Installation","text":" RPython (PowerShell Terminal)\ncmd can locate python correctly PowerShell , execute following\n$env:path=\"$env:Path;C:\\Softwares\\Python\\Python310\"\n\npython command leads Microsoft Store\nWindows | Start | Manage app execution aliases | Disable two ‘python.exe’ ‘python3.exe’\nhides access actual exe PATH comes actual\n\nexecutable gives different path depending upon executed\nPython: C:\\\\Softwares\\\\Python\\\\Python310\nLocal RMarkdown: C:\\\\Program Files\\\\RStudio\\\\bin\nKnit: C:\\\\PROGRA~1\\\\R\\\\R-42~1.1\\\\bin\\\\x64\n\ncmd can locate python correctly PowerShell , execute following\n$env:path=\"$env:Path;C:\\Softwares\\Python\\Python310\"\n$env:path=\"$env:Path;C:\\Softwares\\Python\\Python310\"python command leads Microsoft Store\nWindows | Start | Manage app execution aliases | Disable two ‘python.exe’ ‘python3.exe’\nhides access actual exe PATH comes actual\nWindows | Start | Manage app execution aliases | Disable two ‘python.exe’ ‘python3.exe’hides access actual exe PATH comes actualThe executable gives different path depending upon executed\nPython: C:\\\\Softwares\\\\Python\\\\Python310\nLocal RMarkdown: C:\\\\Program Files\\\\RStudio\\\\bin\nKnit: C:\\\\PROGRA~1\\\\R\\\\R-42~1.1\\\\bin\\\\x64\nPython: C:\\\\Softwares\\\\Python\\\\Python310Local RMarkdown: C:\\\\Program Files\\\\RStudio\\\\binKnit: C:\\\\PROGRA~1\\\\R\\\\R-42~1.1\\\\bin\\\\x64","code":"\nstrsplit(R.version.string, \" \")[[1]][3]           # R Version\n## [1] \"4.2.1\"\n\n# The loaded packages and namespaces are searched before the libraries\npackageVersion(\"knitr\")                           # Package Version: knitr\n## [1] '1.39'# Check, in BASH, if the python has been installed \npython --version\n\n# PATH\nwhere.exe python\n\n# Get the pip Version\nbool_as_str=true;\nif [[ \"$bool_as_str\" == \"true\" ]]; then pip --version; fi\n\n## Python 3.10.5\n## C:\\Softwares\\Python\\Python310\\python.exe\n## pip 22.1.2 from C:\\Softwares\\Python\\Python310\\lib\\site-packages\\pip (python 3.10)# Sys Executable Path\nos.path.dirname(sys.executable)\n## 'C:\\\\PROGRA~1\\\\R\\\\R-42~1.1\\\\bin\\\\x64'\nprint(sys.version.split()[0])           # Python Version\n## 3.10.5\nprint(pd.__version__)                   # Module Version: pandas\n## 1.4.3"},{"path":"introduction-p01.html","id":"install-update-of-r-packages-and-python-modules","chapter":"1 Introduction","heading":"1.16 Install & Update of R Packages and Python Modules","text":" RR: Use HMI\nRStudio | Tools | Check Package Updates | Select | Install Updates\nPackages ‘loaded via namespace’ RStudio start-(e.g. knitr), can updated R\n\nR | Packages | Update Packages | Select | OK\nPackages bundled R (e.g. MASS), can updated starting R Administrator Mode.\n\nRStudio | Tools | Check Package Updates | Select | Install Updates\nPackages ‘loaded via namespace’ RStudio start-(e.g. knitr), can updated R\nPackages ‘loaded via namespace’ RStudio start-(e.g. knitr), can updated RR | Packages | Update Packages | Select | OK\nPackages bundled R (e.g. MASS), can updated starting R Administrator Mode.\nPackages bundled R (e.g. MASS), can updated starting R Administrator Mode.Python: Use pip (PowerShell Terminal)\nInstall modules : pip install pandas\nUpgrade pip : python -m pip install --upgrade pip\nUpgrade modules :\nGet List Outdated Modules Freeze Format, split get Module Names, upgrade\npip list --outdated --format=freeze | %{$_.split(\"==\")[0]} #| %{pip install --upgrade $_}\nNote: Upgrade step pipe commented prevent accidents.\n\nFind whether module installed : pip list | grep pandas\nInstall modules : pip install pandasUpgrade pip : python -m pip install --upgrade pipUpgrade modules :\nGet List Outdated Modules Freeze Format, split get Module Names, upgrade\npip list --outdated --format=freeze | %{$_.split(\"==\")[0]} #| %{pip install --upgrade $_}\nNote: Upgrade step pipe commented prevent accidents.\nGet List Outdated Modules Freeze Format, split get Module Names, upgradepip list --outdated --format=freeze | %{$_.split(\"==\")[0]} #| %{pip install --upgrade $_}Note: Upgrade step pipe commented prevent accidents.Find whether module installed : pip list | grep pandas","code":"\nif(FALSE) {\n  # Install R Packages  \n  install.packages(\"knitr\", dependencies = TRUE)\n  \n  # Find whether a package is installed or not (slow)\n  installed.packages() |> rownames() |> is.element(el = \"knitr\", set = _)\n  \n  # Version of installed package (not loaded)\n  installed.packages()[\"knitr\", \"Version\"]\n}"},{"path":"introduction-p01.html","id":"attach-an-r-package-load-a-python-module","chapter":"1 Introduction","heading":"1.17 Attach an R Package & Load a Python Module","text":" R Python","code":"\nif(FALSE) {\n  # Attach an R Package\n  library(knitr)\n  \n  # Attach multiple R Packages\n  c(\"reticulate\", \"knitr\") |> lapply(library, character.only=TRUE)\n  \n  # List all attached Packages\n  print(.packages())\n}if(False):\n    # Load a Python Module\n    import sys\n    import pandas as pd\n    import numpy as np\n    \n    # Load multiple Python Modules\n    import sys, pandas as pd, numpy as np\n    \n    # List all imported Modules\n    # Works except the implicit import: 'from x import y' (avoid this)\n    # Use k to list alias or use v.__name__ to list actual module names\n    allmodules = [v.__name__ for k, v in globals().items() \n        if type(v) is types.ModuleType and not k.startswith('__')]\n    \n    len(allmodules)\n    \n    \", \".join(allmodules)"},{"path":"introduction-p01.html","id":"r-sessioninfo","chapter":"1 Introduction","heading":"1.18 R sessionInfo()","text":"R sessionInfo() provides quick look OS, locale, packages loadedPython similar -built method. However,\npip list can used along globals()\nModule session_info attempts provide similar output\npip list can used along globals()Module session_info attempts provide similar output R","code":"\nif(FALSE) {\n  # List of all attached packages and OS related information\n  sessionInfo()\n  \n  # Base Packages\n  aa <- c(\"stats\",\"graphics\",\"grDevices\",\"datasets\",\"utils\",\"methods\",\"base\")\n  stopifnot(identical(setdiff(sessionInfo()$basePkgs, aa), character(0)))\n  \n  # other attached packages\n  names(sessionInfo()$otherPkgs)\n  \n  # loaded via a namespace (and not attached)\n  names(sessionInfo()$loadedOnly)\n}"},{"path":"introduction-p01.html","id":"verify","chapter":"1 Introduction","heading":"1.19 Verify","text":" R","code":"\nls()\n## [1] \"aa\" \"bb\" \"r\""},{"path":"structures-p02.html","id":"structures-p02","chapter":"2 Data Structures","heading":"2 Data Structures","text":"","code":""},{"path":"structures-p02.html","id":"r-atomic-vectors-or-data-types","chapter":"2 Data Structures","heading":"2.1 R Atomic Vectors or Data Types","text":"R 6 basic data types (logical, integer, double, character, complex, raw). data types can combined form Data Structures (vector, list, matrix, dataframe, factor).\nVectors simplest type data structure R. vector sequence data elements basic type.\nMembers vector called ‘elements’.\nAtomic vectors homogeneous .e. component datatype.\nvector type can checked typeof() function.\nlist vector ‘atomic vector’.\nVectors simplest type data structure R. vector sequence data elements basic type.Members vector called ‘elements’.Atomic vectors homogeneous .e. component datatype.vector type can checked typeof() function.list vector ‘atomic vector’.Create vector list c()\nR, literal character number just vector length 1.\n, c() ‘combines’ together series 1-length vectors. neither ‘creates’ ‘concatenates’ vectors. combines lists list vectors vector.\nattributes (e.g. dim) except names removed.\narguments coerced common type\noutput type determined highest type components hierarchy NULL < raw < logical < integer < double < complex < character < list < expression.\nR, literal character number just vector length 1., c() ‘combines’ together series 1-length vectors. neither ‘creates’ ‘concatenates’ vectors. combines lists list vectors vector.attributes (e.g. dim) except names removed.arguments coerced common typeThe output type determined highest type components hierarchy NULL < raw < logical < integer < double < complex < character < list < expression. R","code":"\n# Integer: To declare as integer \"L\" (not \"l\") is added as Suffix\nstr(c(1L, 2L, NA, 4L, 5L))\n##  int [1:5] 1 2 NA 4 5\n\n# Double (& Default)\nstr(c(1, 2, NA, 4, 5))\n##  num [1:5] 1 2 NA 4 5\n\n# Character\nstr(c('a', 'b', NA, 'd', 'e'))\n##  chr [1:5] \"a\" \"b\" NA \"d\" \"e\"\n\n# Logical\nstr(c(TRUE, FALSE, NA, FALSE, TRUE))\n##  logi [1:5] TRUE FALSE NA FALSE TRUE"},{"path":"structures-p02.html","id":"examination-of-r-data-types","chapter":"2 Data Structures","heading":"2.2 Examination of R Data Types","text":" R","code":"\n# To know about an Object Named Vector (pi, letters are predefined)\naa <- setNames(c(1, 2, NA, pi, 4), nm = letters[1:5])\n\ntypeof(aa)              # Type\n## [1] \"double\"\nclass(aa)               # Class\n## [1] \"numeric\"\nstr(aa)                 # Structure\n##  Named num [1:5] 1 2 NA 3.14 4\n##  - attr(*, \"names\")= chr [1:5] \"a\" \"b\" \"c\" \"d\" ...\nlength(aa)              # Length\n## [1] 5\ndim(aa)                 # Dimensions\n## NULL\nis(aa)[1:6]             # Inheritance\n## [1] \"numeric\"   \"vector\"    \"index\"     \"replValue\" \"numLike\"   \"number\"\nnames(attributes(aa))   # Attributes\n## [1] \"names\"\nnames(aa)               # Names\n## [1] \"a\" \"b\" \"c\" \"d\" \"e\""},{"path":"structures-p02.html","id":"r-matrices-and-arrays","chapter":"2 Data Structures","heading":"2.3 R Matrices and Arrays","text":"Matrices arrays vectors attribute dim attached \ndata elements must basic type.\nmatrix two-dimensional rectangular data set.\n‘Arrays’ multi-dimensional Data structures. Data stored form matrices, row, well columns.\ndata elements must basic type.matrix two-dimensional rectangular data set.‘Arrays’ multi-dimensional Data structures. Data stored form matrices, row, well columns. R","code":"\n# Create Matrix\naa <- matrix(1:6, nrow=3, ncol=2, byrow=TRUE, dimnames=list(NULL, c(\"x\", \"y\")))\nbb <- matrix(1:6, nrow=3, ncol=2, byrow=FALSE, dimnames=list(NULL, c(\"x\", \"y\")))\n\nprint(aa)\n##      x y\n## [1,] 1 2\n## [2,] 3 4\n## [3,] 5 6\nprint(bb)\n##      x y\n## [1,] 1 4\n## [2,] 2 5\n## [3,] 3 6\n\n# About\nstr(aa)\n##  int [1:3, 1:2] 1 3 5 2 4 6\n##  - attr(*, \"dimnames\")=List of 2\n##   ..$ : NULL\n##   ..$ : chr [1:2] \"x\" \"y\"\ndim(aa)\n## [1] 3 2\nlength(aa)\n## [1] 6\n\n# Matrices have 'dimnames' attribute instead of usual 'names'\nnames(attributes(aa))\n## [1] \"dim\"      \"dimnames\"\nnames(aa)\n## NULL\ndimnames(aa) \n## [[1]]\n## NULL\n## \n## [[2]]\n## [1] \"x\" \"y\""},{"path":"structures-p02.html","id":"r-dataframes","chapter":"2 Data Structures","heading":"2.4 R DataFrames","text":"Data frame list vectors, factors, /matrices length (number rows case matrices).\ndata frame can contain list length components.\ndata frame can contain list length components. R","code":"\n# Create DataFrame (letters is predefined vector of 26 elements)\naa <- data.frame(x = 4:6, y = letters[4:6])\nprint(aa)\n##   x y\n## 1 4 d\n## 2 5 e\n## 3 6 f\n\n# About\nstr(aa)\n## 'data.frame':    3 obs. of  2 variables:\n##  $ x: int  4 5 6\n##  $ y: chr  \"d\" \"e\" \"f\"\ndim(aa)                 #Dimensions Row x Column\n## [1] 3 2\nstopifnot(all(identical(nrow(aa), dim(aa)[1]),\n              identical(ncol(aa), dim(aa)[2])))\n\nnames(attributes(aa))   # Attributes\n## [1] \"names\"     \"class\"     \"row.names\"\nnames(aa)               # Names of column headers\n## [1] \"x\" \"y\"\n\nis.list(aa)\n## [1] TRUE\nis.vector(aa)\n## [1] FALSE\nis.atomic(aa)\n## [1] FALSE"},{"path":"structures-p02.html","id":"r-factors","chapter":"2 Data Structures","heading":"2.5 R Factors","text":"Factors used describe items can finite number values (gender, social class, etc.). factor levels attribute class factor.\nfactor may purely nominal may ordered categories.\nfactor may purely nominal may ordered categories. R","code":"\n# Create Factors Unordered\naa <- factor(c(\"female\", \"male\", \"male\", \"female\", \"male\"), ordered = FALSE)\n# Create Factors Ordered\nbb <- factor(c(\"female\", \"male\", \"male\", \"female\", \"male\"), ordered = TRUE)\n\nprint(aa)\n## [1] female male   male   female male  \n## Levels: female male\nprint(bb)\n## [1] female male   male   female male  \n## Levels: female < male\n\n# About\nstr(aa)\n##  Factor w/ 2 levels \"female\",\"male\": 1 2 2 1 2\nstr(bb)\n##  Ord.factor w/ 2 levels \"female\"<\"male\": 1 2 2 1 2\n\nnlevels(aa)             # Count of Levels\n## [1] 2\nlevels(aa)              # Vector of Levels\n## [1] \"female\" \"male\"\nnames(attributes(aa))   # Attributes\n## [1] \"levels\" \"class\""},{"path":"structures-p02.html","id":"membership-functions","chapter":"2 Data Structures","heading":"2.6 Membership Functions","text":"anyNA() TRUE NA present, FALSE otherwiseis.atomic() TRUE atomic vectors, factors, matrices FALSE lists dataframesis.vector() TRUE atomic vectors, lists FALSE factors, matrices, DATE & POSIXct\nreturns FALSE vector attributes (except names) ex: DATE, POSIXct, DataFrames (even though Dataframe list list vector)\nreturns FALSE vector attributes (except names) ex: DATE, POSIXct, DataFrames (even though Dataframe list list vector).numeric() TRUE integer doubleis.integer(), .double(), .character(), .logical() TRUE respective datatypes onlyis.factor(), .ordered() membership functions factors without ordering respectively R","code":"\n# Create Objects\naa_num <- setNames(c(1, 2, NA, pi, 4), nm = letters[1:5])\nbb_mat <- matrix(1:6, nrow=3, ncol=2, byrow=TRUE)\ndd_dft <- data.frame(x = 4:6, y = letters[4:6])\nee_lst <- list(x = 4:6, y = letters[4:8])\nff_fct <- factor(c(\"female\", \"male\", \"male\", \"female\", \"male\"), ordered = FALSE)\n\n# List of Objects\ngg <- list(Vector = aa_num, Matrix = bb_mat, DataFrame = dd_dft, \n            List = ee_lst, Factor = ff_fct)\n\n# Apply a membership function on all of the objects inside the list\nnames(which(sapply(gg, is.atomic)))\n## [1] \"Vector\" \"Matrix\" \"Factor\"\nnames(which(sapply(gg, is.vector)))\n## [1] \"Vector\" \"List\"\nnames(which(sapply(gg, is.matrix)))\n## [1] \"Matrix\"\nnames(which(sapply(gg, is.list)))\n## [1] \"DataFrame\" \"List\"\nnames(which(sapply(gg, is.data.frame)))\n## [1] \"DataFrame\"\nnames(which(sapply(gg, is.factor)))\n## [1] \"Factor\""},{"path":"structures-p02.html","id":"python-types","chapter":"2 Data Structures","heading":"2.7 Python Types","text":"(doc) Built-Types(doc) Built-TypesGeneral\nprincipal built-types numerics, sequences, mappings, classes, instances exceptions.\ncollection classes mutable. methods add, subtract, rearrange members place, return specific item, never return collection instance None.\nPractically objects can compared equality, tested truth value, converted string.\nGeneralThe principal built-types numerics, sequences, mappings, classes, instances exceptions.collection classes mutable. methods add, subtract, rearrange members place, return specific item, never return collection instance None.Practically objects can compared equality, tested truth value, converted string.Truth Value Testing\nconstants defined false: None False.\nzero numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)\nempty sequences collections: '', (), [], {}, set(), range(0)\nTruth Value Testingconstants defined false: None False.zero numeric type: 0, 0.0, 0j, Decimal(0), Fraction(0, 1)empty sequences collections: '', (), [], {}, set(), range(0)Boolean Operations ascending order: , , notBoolean Operations ascending order: , , notThere eight comparison operations Python.eight comparison operations Python.Numeric Types: int, float, complex\nBooleans subtype integers\nPython Integers unlimited precision. Whereas, R integers limited \\((2^{31} - 1 = 2147483647)\\)\nNumeric Types: int, float, complexBooleans subtype integersPython Integers unlimited precision. Whereas, R integers limited \\((2^{31} - 1 = 2147483647)\\)Iterator Types\nSequences always support iteration methods.\nIterator TypesSequences always support iteration methods.Sequence Types: list, tuple, range\nNegative value index relative end sequence Python. Whereas, acts exclude indices\nConcatenating immutable sequences always results new object.\nrange type represents immutable sequence numbers commonly used looping specific number times loops.\nSequence Types: list, tuple, rangeNegative value index relative end sequence Python. Whereas, acts exclude indicesConcatenating immutable sequences always results new object.range type represents immutable sequence numbers commonly used looping specific number times loops.Text Sequence Type: str\nStrings immutable sequences Unicode code points.\nText Sequence Type: strStrings immutable sequences Unicode code points.Set Types: set (mutable), frozenset (immutable)Set Types: set (mutable), frozenset (immutable)Mapping Types: dictMapping Types: dict","code":""},{"path":"structures-p02.html","id":"similarity-r-python","chapter":"2 Data Structures","heading":"2.8 Similarity (R & Python)","text":" R Python","code":"\n# R results are same as Python\nstopifnot(0  == 1 %/% 2 )\nstopifnot(-1 == (-1) %/% 2 )\nstopifnot(-1 == 1 %/% (-2) )\nstopifnot(0  == (-1) %/% (-2) )\n\n# 1^y and y^0 are 1, ALWAYS in both R and Python\nstopifnot(all(sapply(list(0**0, NaN**0, NA**0, Inf**0, 1**NA, 1**NaN), \n                     identical, 1)))\n\nstopifnot(is.nan(NaN * 0))\nstopifnot(is.na(NA * 0) & !is.nan(NA * 0))        #NA\n\nstopifnot(is.nan(Inf * 0))# Python results are same as R\nassert(0  == 1//2 )\nassert(-1 == (-1) // 2 )\nassert(-1 == 1 // (-2) )\nassert(0  == (-1) // (-2) )\n\n# 1^y and y^0 are 1, ALWAYS in both R and Python\nassert(1 == 0**0 == np.nan**0 == 1**np.nan)\n\nassert(np.isnan(np.nan * 0))\nassert(np.isnan(math.inf * 0))"},{"path":"structures-p02.html","id":"differences-r-python","chapter":"2 Data Structures","heading":"2.9 Differences (R & Python)","text":" R R Python","code":"\n# R allows division by zero whereas Python throws ZeroDivisionError\nstopifnot(is.na(0L %/% 0L) & !is.nan(0L %/% 0L))  #NA\nstopifnot(is.nan(0 %/% 0 ))                       #NaN\nstopifnot(is.infinite(1 %/% 0))                   #Inf\n# R index starts from 1, whereas Python index starts from 0\n# R range includes the maximum value, whereas Python excludes it\nseq.int(length.out = 5)\n## [1] 1 2 3 4 5\nseq.int(from = 0, length.out = 5)\n## [1] 0 1 2 3 4\nseq.int(to = 10, length.out = 5)\n## [1]  6  7  8  9 10\nseq.int(by = -2, length.out = 5)\n## [1]  1 -1 -3 -5 -7\n\n# Colon \":\" acts as sequence in R, Python uses colon for dictionary key:value\n# Colon should be avoided in R if the range limits may change\n1:5\n## [1] 1 2 3 4 5\n1:0\n## [1] 1 0# Python index starts from 0, whereas R index starts from 1\n# Python range excludes the maximum value, whereas R includes it\nlist(range(5))\n## [0, 1, 2, 3, 4]\nlist(range(1, 6))\n## [1, 2, 3, 4, 5]\nlist(range(10, 1, -2))\n## [10, 8, 6, 4, 2]"},{"path":"structures-p02.html","id":"python-collections","chapter":"2 Data Structures","heading":"2.10 Python Collections","text":"Python Collections: List, Tuple, Set, Dictionary\ntuple: Literal (), Ordered, Immutable, Allows Duplicates, Refer\nlist : Literal [], Ordered, Mutable, Allows Duplicates, Refer\ndict : Literal {}, Ordered, Mutable, Duplicates, Refer\nset : Literal {}, Unordered, Mutable, Duplicates, Refer\nEffectively, ‘sets’ ‘dictionaries’ without keys\nIndexing slicing work set unordered\nImmutable objects include numbers, strings tuples. Refer.\nset converted R environment. However, tricky handle, put hold now. Note python set operations like ‘set difference’ can applied using scope resolution .e. py$set_x$difference(set_y)\n\ntuple: Literal (), Ordered, Immutable, Allows Duplicates, Referlist : Literal [], Ordered, Mutable, Allows Duplicates, Referdict : Literal {}, Ordered, Mutable, Duplicates, Referset : Literal {}, Unordered, Mutable, Duplicates, Refer\nEffectively, ‘sets’ ‘dictionaries’ without keys\nIndexing slicing work set unordered\nImmutable objects include numbers, strings tuples. Refer.\nset converted R environment. However, tricky handle, put hold now. Note python set operations like ‘set difference’ can applied using scope resolution .e. py$set_x$difference(set_y)\nEffectively, ‘sets’ ‘dictionaries’ without keysIndexing slicing work set unorderedImmutable objects include numbers, strings tuples. Refer.set converted R environment. However, tricky handle, put hold now. Note python set operations like ‘set difference’ can applied using scope resolution .e. py$set_x$difference(set_y) Python","code":"pp = 11                                           # int\nprint(f\"{type(pp) = }   |     ...     | {pp = }\")\n## type(pp) = <class 'int'>   |     ...     | pp = 11\npp = 11,                                          # Implicit Tuple\nprint(f\"{type(pp) = } | {len(pp) = } | {pp = }\")\n## type(pp) = <class 'tuple'> | len(pp) = 1 | pp = (11,)\npp = (11, )                                       # Length 1 Tuple needs comma\nprint(f\"{type(pp) = } | {len(pp) = } | {pp = }\")\n## type(pp) = <class 'tuple'> | len(pp) = 1 | pp = (11,)\npp = (11, 22, 33)                                 # Tuple\nprint(f\"{type(pp) = } | {len(pp) = } | {pp = }\")\n## type(pp) = <class 'tuple'> | len(pp) = 3 | pp = (11, 22, 33)\npp = [11, 22, 33]                                 # List\nprint(f\"{type(pp) = }  | {len(pp) = } | {pp = }\")\n## type(pp) = <class 'list'>  | len(pp) = 3 | pp = [11, 22, 33]\npp = {11, 22, 33}                                 # Set (unordered)\nprint(f\"{type(pp) = }   | {len(pp) = } | {pp = }\")\n## type(pp) = <class 'set'>   | len(pp) = 3 | pp = {33, 11, 22}\npp = {\"a\": 11, \"b\": 22, \"c\": 33}                  # Dictionary\nprint(f\"{type(pp) = }  | {len(pp) = } | {pp = }\")\n## type(pp) = <class 'dict'>  | len(pp) = 3 | pp = {'a': 11, 'b': 22, 'c': 33}"},{"path":"structures-p02.html","id":"numpy-array","chapter":"2 Data Structures","heading":"2.11 NumPy Array","text":" Python","code":"pp = np.arange(12).reshape((3,4))\nprint(type(pp))\n## <class 'numpy.ndarray'>\nprint(pp)\n## [[ 0  1  2  3]\n##  [ 4  5  6  7]\n##  [ 8  9 10 11]]\nassert(np.array_equal(pp[0, :], pp[0, ]))         #Verify same shape & values\nprint(pp[0, ])                                    #Subset First Row\n## [0 1 2 3]"},{"path":"structures-p02.html","id":"pandas-dataframe","chapter":"2 Data Structures","heading":"2.12 Pandas DataFrame","text":" Python","code":"#"},{"path":"list-dict-p03.html","id":"list-dict-p03","chapter":"3 R List & Python Dictionary","heading":"3 R List & Python Dictionary","text":"","code":""},{"path":"list-dict-p03.html","id":"basics-1","chapter":"3 R List & Python Dictionary","heading":"3.1 Basics","text":"R list : CRAN Lists\nR list object consisting ordered collection objects known ‘components’.\ncomponent can type R object length. can even include list, environment etc.\n\nComponents always numbered. Components may also named.\nvector names fact simply attribute list.\n\\([[ \\ldots ]]\\) vs. \\([ \\ldots ]\\)\n[[ ]] operator used select single element, whereas [ ] general subscripting operator.\nThus [[ ]] provides first object list, named list name included.\nHowever, [ ] provides sublist list consisting first entry . named list, names transferred sublist.\n\nlist vector ‘atomic vector’\nR list object consisting ordered collection objects known ‘components’.\ncomponent can type R object length. can even include list, environment etc.\ncomponent can type R object length. can even include list, environment etc.Components always numbered. Components may also named.vector names fact simply attribute list.\\([[ \\ldots ]]\\) vs. \\([ \\ldots ]\\)\n[[ ]] operator used select single element, whereas [ ] general subscripting operator.\nThus [[ ]] provides first object list, named list name included.\nHowever, [ ] provides sublist list consisting first entry . named list, names transferred sublist.\n[[ ]] operator used select single element, whereas [ ] general subscripting operator.Thus [[ ]] provides first object list, named list name included.However, [ ] provides sublist list consisting first entry . named list, names transferred sublist.list vector ‘atomic vector’Python dict : Python Dictionary\ndict : Literal {}, Ordered, Mutable, Duplicates\nDictionaries compare equal (key, value) pairs (regardless ordering).\nEssentially means ‘insertion ordered’ different ordered like OrderedDict\nEquality comparisons OrderedDict order sensitive case dict\ndict : Literal {}, Ordered, Mutable, DuplicatesDictionaries compare equal (key, value) pairs (regardless ordering).Essentially means ‘insertion ordered’ different ordered like OrderedDictEquality comparisons OrderedDict order sensitive case dictCreate & Print R PythonOrder sensitive comparison done R list. However, Python consider position dict comparison R PythonCount Components R PythonNames Types R PythonSlice Subset Select: R index starts 1 whereas Python index starts 0 R PythonType checking R PythonMerge Combine R allows duplicate components Python overwrites (Last seen wins) R PythonAdd Update Components R PythonDelete components R Python","code":"\naa = list()                                       #Empty List\nprint(aa)\n## list()\n\naa <- list(x = c(11L, 12L), y = c(\"a\", \"b\", \"c\")) #Simple List\nprint(aa)\n## $x\n## [1] 11 12\n## \n## $y\n## [1] \"a\" \"b\" \"c\"\n\nstr(aa)                                           #Structure\n## List of 2\n##  $ x: int [1:2] 11 12\n##  $ y: chr [1:3] \"a\" \"b\" \"c\"pp = {}                                           #Empty Dictionary\nprint(f\"{type(pp) = } | {len(pp) = } | {pp = }\")\n\n## type(pp) = <class 'dict'> | len(pp) = 0 | pp = {}\npp = {\"x\": [11, 12], \"y\": (\"a\", \"b\", \"c\")}        #Simple Dictionary\nprint(f\"{len(pp)=}, {pp = }\")\n## len(pp)=2, pp = {'x': [11, 12], 'y': ('a', 'b', 'c')}\n# Create list by separately supplying component names\naa <- list(x = c(11L, 12L), y = c(\"a\", \"b\", \"c\"))\nbb <- setNames(list(c(11L, 12L), c(\"a\", \"b\", \"c\")), nm = c(\"x\", \"y\"))\nstopifnot(identical(aa, bb))\n\ndd <- list(y = c(\"a\", \"b\", \"c\"), x = c(11L, 12L))\nstopifnot(!identical(aa, dd))           #FALSE: R considers position\n#To ignore position (like Python)\nstopifnot(identical(aa[order(names(aa))], dd[order(names(dd))]))# Create dict by separately supplying component names\npp = {\"x\": [11, 12], \"y\": (\"a\", \"b\", \"c\")}\nqq = dict(zip([\"x\", \"y\"], [[11, 12], (\"a\", \"b\", \"c\")]))\n\nss = {\"y\": (\"a\", \"b\", \"c\"), \"x\": [11, 12]}\nassert(pp == qq == ss)                  #True: Python does not consider position\nassert(list(pp.items()) != list(ss.items()))      #To consider position (like R)\naa <- list(x = c(11L, 12L), y = c(\"a\", \"b\", \"c\")) #Simple List\nlength(aa)                                        #Count components\n## [1] 2\n\nlengths(aa)                                       #Count elements of components\n## x y \n## 2 3pp = {\"x\": [11, 12], \"y\": (\"a\", \"b\", \"c\")}        #Simple Dictionary\nlen(pp)                                           #Count key: value pairs\n\n## 2\n{k:len(v) for k, v in pp.items()}                 #Count length of each pair\n## {'x': 2, 'y': 3}\naa <- list(x = c(11L, 12L), y = c(\"a\", \"b\", \"c\")) #Simple List\nnames(attributes(aa))                             #Attributes\n## [1] \"names\"\n\nbb <- names(aa)                                   #Names of components\nbb\n## [1] \"x\" \"y\"\n\n# Find Names\nstopifnot(all( 'x' %in% bb,  any('x' == bb),  is.element('x', set = bb), \n              !'z' %in% bb, !any('z' == bb), !is.element('z', set = bb))) \n\n# Note: %in% operator is NOT commutative i.e. a %in% b != b %in% a\nstopifnot(! identical(1 %in% c(1, 2), c(1, 2) %in% 1))\n\nsapply(aa, typeof)                                #Type of components\n##           x           y \n##   \"integer\" \"character\"pp = {\"x\": [11, 12], \"y\": (\"a\", \"b\", \"c\")}        #Simple Dictionary\nlist(pp.keys())                                   #List of keys\n## ['x', 'y']\nassert(\"x\" in pp.keys() and \"z\" not in pp.keys()) #Find Keys\n\nlist(pp.values())                                 #List of Values\n\n## [[11, 12], ('a', 'b', 'c')]\nlist(pp.items())                                  #List of items\n\n## [('x', [11, 12]), ('y', ('a', 'b', 'c'))]\nprint(\"\\n\".join([k + \" : \" + str(type(pp[k]).__name__) \n                for k, v in pp.items()]))         #Type of items\n## x : list\n## y : tuple\naa <- list(x = c(11L, 12L), y = c(\"a\", \"b\", \"c\")) #Simple List\n\nbb <- aa[[1]]                                     #[[ ]] First Object: index 1\nstopifnot(all(sapply(list(aa$x, aa[[\"x\"]]), identical, bb)))\nprint(bb)\n## [1] 11 12\nstr(bb)\n##  int [1:2] 11 12\n\ndd <- aa[1]                                       #[ ] Sublist with First Entry\nprint(dd)\n## $x\n## [1] 11 12\nstr(dd)\n## List of 1\n##  $ x: int [1:2] 11 12pp = {\"x\": [11, 12], \"y\": (\"a\", \"b\", \"c\")}        #Simple Dictionary\n\nqq = list(pp.items())[0]                          #First Object: index 0\nprint(f\"{type(qq) = } | {len(qq) = } | {qq = }\")  #Converted to Tuple\n\n## type(qq) = <class 'tuple'> | len(qq) = 2 | qq = ('x', [11, 12])\nqq = pp['x']                                    \nprint(f\"{type(qq) = } | {len(qq) = } | {qq = }\")  #Keep original as list\n## type(qq) = <class 'list'> | len(qq) = 2 | qq = [11, 12]\naa <- list(x = c(11L, 12L), y = c(\"a\", \"b\", \"c\")) #Simple List\nstopifnot(is.list(aa))\n\nstopifnot(is.vector(aa))                          #TRUE: list is vector\n\nstopifnot(!is.atomic(aa))                         #FALSE: list is not atomicpp = {\"x\": [11, 12], \"y\": (\"a\", \"b\", \"c\")}        #Simple Dictionary\n\nassert(pp.__class__ is dict)                      #same as type() (Avoid)\n\nassert(type(pp) is dict)                          #type() (Strict)\n\nassert(isinstance(pp, dict))                      #isinstance() allows subtypes\n\nassert(isinstance(False, int))                    #True: bool is subtype of int\nassert(type(False) is not int)\naa <- list(\"a\" = 11L, \"b\" = 22L)\nbb <- list(\"c\" = 33L, \"b\" = 222L)\n\ndd <- c(aa, bb)                         #R keeps duplicates (Avoid)\nstr(dd)\n## List of 4\n##  $ a: int 11\n##  $ b: int 22\n##  $ c: int 33\n##  $ b: int 222\n\nee <- modifyList(aa, val = bb)          #To overwrite duplicates (like Python)\nstr(ee)\n## List of 3\n##  $ a: int 11\n##  $ b: int 222\n##  $ c: int 33\n\n#Overwrite duplicates: This may result in position change of key\nstr(c(aa, bb)[!duplicated(c(names(aa), names(bb)), fromLast = TRUE)])\n## List of 3\n##  $ a: int 11\n##  $ c: int 33\n##  $ b: int 222pp = {\"a\": 11, \"b\": 22}\nqq = {\"c\": 33, \"b\": 222}\n\nss = copy.deepcopy(pp)\nss.update(qq)                           #Update in-place\n\ntt = {**pp, **qq}                       #Merge using **\n\nuu = pp | tt                            #Merge using |\n\nvv = copy.deepcopy(pp)\nvv |= qq                                #Update in-place using |=\nassert(ss == tt == uu == vv)\n\nprint(f\"{len(ss)=}, {ss = }\")\n## len(ss)=3, ss = {'a': 11, 'b': 222, 'c': 33}\naa <- list(\"a\" = 11L, \"b\" = 22L)\n\naa$b <- 222L\naa$b\n## [1] 222\n\naa[[\"b\"]] <- 22L\n\naa$c <- 33L\nstr(aa)\n## List of 3\n##  $ a: int 11\n##  $ b: int 22\n##  $ c: int 33pp = {\"a\": 11, \"b\": 22}\n\npp[\"b\"] = 200                                     #subscript notation\npp[\"c\"] = 33\nassert(pp['b'] == 200)\n\npp.update({\"b\": 300})                             #Slow\nassert(pp['b'] == 300)\n\npp.update([(\"b\", 22)])                            #Slow\nassert(pp['b'] == 22)\n\nprint(f\"{len(pp)=}, {pp = }\")\n## len(pp)=3, pp = {'a': 11, 'b': 22, 'c': 33}\naa <- list(\"a\" = 11L, \"b\" = 22L, \"c\" = 33L)\n\nbb <- within(aa, rm(\"b\", \"c\"))                    #Error if key not found\n\nbb[c(\"b\", \"c\", \"xyz\")] <- NULL                    #No error if key not found\n\ndd <- bb[setdiff(names(aa), c(\"b\", \"c\", \"xyz\"))]  #No error if key not found\nstopifnot(identical(bb, dd))\nstr(bb)\n## List of 1\n##  $ a: int 11pp = {\"a\": 11, \"b\": 22, \"c\": 33}\nqq = copy.deepcopy(pp)\nss = copy.deepcopy(pp)\ntt = copy.deepcopy(pp)\n\nuu = {k: v for k, v in pp.items() if k not in (\"b\", \"c\", \"xyz\")} #Slow\n\nfor k in (\"b\", \"c\"): del qq[k]          #Return None, Error if key not found\n\nfor k in (\"b\", \"c\"): ss.pop(k)          #Return Value, Error if key not found\n## 22\n## 33\nfor k in (\"xyz\"): ss.pop(k, None)       #Using None, No error if key not found\n\n[tt.pop(k) for k in (\"b\", \"c\")]\n## [22, 33]\n[tt.pop(k, None) for k in (\"xyz\")]\n\n## [None, None, None]\nassert(qq == ss == tt == uu)\nprint(f\"{len(qq)=}, {qq = }\")\n## len(qq)=1, qq = {'a': 11}"},{"path":"list-dict-p03.html","id":"nested","chapter":"3 R List & Python Dictionary","heading":"3.2 Nested","text":" R Python","code":"\naa <- list(\"a\" = 11L, \"b\" = 22L)\nbb <- list(\"c\" = 33L, \"d\" = 44L, \"e\" = aa)        #Nested List\nstr(bb)\n## List of 3\n##  $ c: int 33\n##  $ d: int 44\n##  $ e:List of 2\n##   ..$ a: int 11\n##   ..$ b: int 22pp = {\"a\": 11, \"b\": 22}\nqq = {\"c\": 33, \"d\": 44, \"e\": pp}                  #Nested Dictionary\nprint(f\"{len(qq)=}, {qq = }\")\n## len(qq)=3, qq = {'c': 33, 'd': 44, 'e': {'a': 11, 'b': 22}}"},{"path":"list-dict-p03.html","id":"with-multiple-datatypes","chapter":"3 R List & Python Dictionary","heading":"3.3 With Multiple DataTypes","text":" R Python R Python","code":"\naa_lst <- list(11L, 22L)                #Unnamed List   | Tuple\nbb_lst <- list(a = 11L, b = 22L)        #Named List     | Dict\ndd_vec <- c(11L, 22L)                   #Unnamed Vector | List\n\nee <- list(a = 11L, b = \"x\", c = FALSE, d = NULL, \n           e = aa_lst, f = dd_vec, g = bb_lst)\nlst_r <- ee                             #R list to transform into Python dict\n#str(ee)# Exclude Python sets because these are converted to R Environment\npp_tup = (11, 22)             #Tuple: Ordered, Immutable | Unnamed List\nqq_lst = [11, 22]             #List: Ordered, Mutable    | Unnamed Vector\nss_dic = {\"a\": 11, \"b\": 22}   #Dict: Ordered, Mutable    | Named List\n\ntt = {\"a\": 11, \"b\": \"x\", \"c\": False, \"d\": None, \n      \"e\": pp_tup, \"f\": qq_lst, \"g\": ss_dic}\ndic_y = copy.deepcopy(tt)     #Python dict to transform into R list\n\n#print(\"\\n\".join([k + \" : \" + str(type(tt[k]).__name__) + \" : \" + str(v) \n#                for k, v in tt.items()]))\naa <- py$dic_y                          #Convert Python dict to R List\nstopifnot(identical(lst_r, aa))         #TRUE\nstr(aa)\n## List of 7\n##  $ a: int 11\n##  $ b: chr \"x\"\n##  $ c: logi FALSE\n##  $ d: NULL\n##  $ e:List of 2\n##   ..$ : int 11\n##   ..$ : int 22\n##  $ f: int [1:2] 11 22\n##  $ g:List of 2\n##   ..$ a: int 11\n##   ..$ b: int 22pp = r.lst_r                            #Convert R List to Python dict\npp[\"e\"] = tuple(pp[\"e\"])                #List to Tuple\nassert(dic_y == pp)                     #True\n\nprint(\"\\n\".join([k + \" : \" + str(type(pp[k]).__name__) + \" : \" + str(v) \n                for k, v in pp.items()]))\n## a : int : 11\n## b : str : x\n## c : bool : False\n## d : NoneType : None\n## e : tuple : (11, 22)\n## f : list : [11, 22]\n## g : dict : {'a': 11, 'b': 22}"}]
